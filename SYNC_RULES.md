# 同步算法设计规则

## 核心原则：同步精度至上

在本项目的同步算法设计中，**永远没有"浪费"这一说**。只要能把同步精度提高哪怕一毫秒，就是正确的设计。

唯一的约束：在保证用户听感的基础上追求精度。不能为了精度牺牲听感（如频繁硬重置导致卡顿）。

## 设计准则

1. **每一毫秒都值得争取** — 不要因为"够用了"就停止优化。5ms 和 3ms 的差距是值得投入的。
2. **测量必须纯净** — drift 测量基于真实锚点，不被纠正操作污染。测量和纠正严格分离。
3. **纠正必须分层** — 小漂移用无感方式（调整未排列 segment 时间），中漂移用渐进方式（playbackRate），大漂移才硬重置。层次越多，用户感知越少。
4. **硬件精度优先** — 能用 AudioContext 硬件时钟调度的，绝不用 setTimeout。能预约到精确时刻的，绝不用"立即播放+补偿"。
5. **采样质量 > 采样数量** — 高质量的低 RTT 样本比大量噪声样本更有价值。但在需要快速响应时，频率不能降。
6. **反馈环必须稳定** — 任何纠正机制都要确认不会引入振荡。纠正后的状态不能反过来干扰下一次测量。
7. **边界场景不放过** — 页面后台恢复、网络切换、切歌、新用户加入，每个场景都要有明确的重同步策略。

## 当前架构

- **ClockSync** — NTP 式对时，performance.now() 测 RTT，取最低 RTT 样本算 offset
- **Lookahead Scheduler** — 前瞻调度，200ms 检查间隔，只排未来 1.5s 的 segment
- **漂移纠正** — 软纠正（调 _nextSegTime）+ 硬重置（playAtPosition），syncTick 驱动
- **预约起播** — scheduledAt 硬件时间线预约，AudioContext.start(time) 精确调度
